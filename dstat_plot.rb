#! /usr/bin/ruby

require 'gnuplot'
require 'csv'
require 'optparse'
require 'pry'

"""
dstat_plot
plots csv data generated by dstat
""" 

$verbose = false
Y_DEFAULT = 105.0

def plot(dataset_container, category, field, dry, filename)
  Gnuplot.open do |gp|
    Gnuplot::Plot.new(gp) do |plot|
      plot.title dataset_container[:plot_title]
      plot.xlabel "Time in seconds"
      plot.ylabel "#{category}: #{field}"
      range_max = dataset_container[:y_max]
      plot.yrange "[0:#{range_max}]"
      if dataset_container[:autoscale] then plot.set "autoscale" end
      plot.key "out vert right top"
      
      unless dry
        plot.terminal 'png size 1600,800 enhanced font "Helvetica,11"'
        plot.output filename
        puts "Saving plot to '#{filename}'"
      end

      plot.data = dataset_container[:datasets]
    end
  end
end

# Create the GnuplotDataSet that is going to be printed.
# Params:
# +timecode:: Array containing the timestamps
# +values:: Array containing the actual values
# +no_plot_key:: boolean to de-/activate plotkey
# +file:: file
def create_gnuplot_dataset(timecode, values, no_plot_key, file)
  Gnuplot::DataSet.new([timecode, values]) do |gp_dataset|
    gp_dataset.with = "lines"
    if no_plot_key then
      gp_dataset.notitle
    else
      gp_dataset.title = File.basename file
    end
  end
end

def analyze_header_create_plot_title(prefix, inversion, csv_header)
  plot_title = "#{prefix} over time"
  if csv_header[2].index("Host:")
    plot_title += '\n' + "(Host: #{csv_header[2][1]} User: #{csv_header[2][6]} Date: #{csv_header[3].last})"
  end
  if inversion then plot_title += '\n(inverted)' end
  plot_title
end

# returns the values from a headerless csv file
def read_column_from_csv(files, column, no_plot_key, y_max, inversion)
  plot_title = nil
  datasets = []
  autoscale = false

  files.each do |file|
    if $verbose then puts "Reading from csv to get column #{column}." end
    csv = CSV.read(file)

    if plot_title.nil?
      plot_title = analyze_header_create_plot_title("dstat-column #{column}", inversion != 0.0, csv[0..6])
    end

    if csv[2].index "Host:"
      csv = csv.drop(7)
    end

    csv = csv.transpose
    timecode = csv[0].map { |timestamp| timestamp.to_f - csv[0].first.to_f }

    values = csv[column]
    if inversion != 0.0
        values.map! { |value| (value.to_f - inversion).abs }
        y_max = inversion + 5.0
    end
    
    if y_max == Y_DEFAULT
        max_value = values.max { |a, b| a.to_f <=> b.to_f }
        if max_value.to_f > y_max then y_max = max_value end    
    end

    dataset = create_gnuplot_dataset(timecode, values, no_plot_key, file)
    datasets.push dataset
  end

  if $verbose then puts "datasets: #{datasets.count} \nplot_title: #{plot_title} \ny_range: #{y_range} \nautoscale: #{autoscale}" end

  dataset_container = { :datasets => datasets, :plot_title => plot_title, :y_range => {:max => y_max}, :autoscale => autoscale }
end

def read_csv(category, field, files, no_plot_key, y_range, inversion)
  if $verbose then puts "Reading from csv." end

  plot_title = "#{category}-#{field}"

  if inversion != 0.0
    y_range = {:enforced => true, :max => inversion + 5}
    plot_title += " inverted"
  end
  
  filename = "#{plot_title}.png".sub("/", "_")

  plot_title +=  ' over time \n'
  plot_title_not_complete = true

  datasets = []
  autoscale = false

  files.each do |file|
    CSV.open(file) do |csv_file|
      current_row = csv_file.shift
      # loop until row with "epoch" in it is reached and read some meta data 
      # but only for the first file since there can only be one title
      while current_row.index("epoch").nil? do
        if plot_title_not_complete
          if current_row.index("Host:") != nil
            plot_title += "(Host: #{current_row[1]} User: #{current_row[6]}"
          elsif current_row.index("Cmdline:") != nil
            plot_title += " Date: #{current_row.last})"
            plot_title_not_complete = false
          end
        end
        current_row = csv_file.shift
      end

      # find the epoch category == nil if not found
      epoch_index = current_row.index("epoch")

      category_index = current_row.index(category)
    	if category_index.nil?
    		puts "#{category} is not a valid parameter for 'category'. Value could not be found."
        puts "Allowed categories: #{current_row.reject{ |elem| elem == nil }.inspect}"
    		exit 1
    	end
    	
    	current_row_at_category = csv_file.shift.drop(category_index)
      field_offset = current_row_at_category.index(field)
    	if field_offset.nil?
    		puts "#{field} is not a valid parameter for 'field'. Value could not be found."
        puts "Allowed fields: #{current_row_at_category.inspect}"
    		exit 1
      else
        field_index = category_index + field_offset
    	end

      # get all the interesting values and put them in an array
    	current_row = csv_file.shift
      unless epoch_index.nil? then time_offset = current_row.at(epoch_index).to_f end
      timecode = []
      values = []
      until csv_file.eof do
        unless epoch_index.nil? then timecode.push(current_row.at(epoch_index).to_f - time_offset) end
        values.push (current_row.at(field_index).to_f - inversion).abs
        if !y_range[:enforced]
          if values.last.to_f >= y_range[:max] then autoscale = true end
        end
        current_row = csv_file.shift
      end

      if epoch_index.nil? then timecode = (0..values.count - 1).to_a end

      dataset = create_gnuplot_dataset(timecode, values, no_plot_key, file)
      datasets.push dataset
    end
  end

  if $verbose then puts "datasets: #{datasets.count} \nplot_title: #{plot_title} \ny_range: #{y_range} \nautoscale: #{autoscale}" end

  dataset_container = {:datasets => datasets, :plot_title => plot_title, :y_range => y_range, :autoscale => autoscale, :filename => filename}
end


def read_options_and_arguments
  opts = {} # Hash that hold all the options

  optparse = OptionParser.new do |parser|
    # banner that is displayed at the top
    parser.banner = "Usage: \n
    dstat_plot.rb [options] -c CATEGORY -f FIELD [directory | file1 file2 ...] or \n 
    dstat_plot.rb [options] -l COLUMN [directory | file1 file2 ...]"

    ### options and what they do
    parser.on('-v', '--verbose', 'Output more information') do
      $verbose = true
    end

    opts[:inversion] = 0.0
    parser.on('-i', '--invert [VALUE]', Float, 'Invert the graph such that inverted(x) = VALUE - f(x),', 'default is 100.') do |value|
      opts[:inversion] = value.nil? ? 100.0 : value
    end

    opts[:no_plot_key] = false
    parser.on('-n','--no-key', 'No plot key is printed.') do
      opts[:no_plot_key] = true
    end

    opts[:dry] = false
    parser.on('-d', '--dry', 'Dry run. Plot is not saved to file but instead displayed with gnuplot.') do
      opts[:dry] = true
    end

    opts[:output] = nil
    parser.on('-o','--output FILE|DIR', 'File or Directory that plot should be saved to.', 'If a directory is given the filename will be generated.', 'Default is csv file directory.') do |path|
      opts[:output] = path
    end

    opts[:y_range] = {:max => 105.0, :enforced => false} # TODO:remove enforced, it won't be used in future verions
    opts[:y_max] = Y_DEFAULT
    parser.on('-y', '--y-range RANGE', Float, 'Sets the y-axis range. Default is 105. If a value exceeds', 'this range, "autoscale" is enabled.') do |range|
      opts[:y_range] = {:max => range, :enforced => true} # TODO:remove enforced, it won't be used in future verions
      opts[:y_max] = range
    end

    opts[:category] = nil
    parser.on('-c', '--category CATEGORY', 'Select the category.') do |category|
      opts[:category] = category
    end

    opts[:field] = nil
    parser.on('-f', '--field FIELD' , 'Select the field.') do |field|
      opts[:field] = field
    end

    opts[:column] = nil
    parser.on('-l', '--column COLUMN', 'Select the desired column directly.') do |column|
      unless opts[:category] && opts[:field]  # -c and -f override -l
        opts[:column] = column.to_i
      end
    end

    # This displays the help screen
    parser.on_tail('-h', '--help', 'Display this screen.' ) do
      puts parser
      exit
    end
  end

  # there are two forms of the parse method. 'parse' 
  # simply parses ARGV, while 'parse!' parses ARGV 
  # and removes all options and parameters found. What's
  # left is the list of files
  optparse.parse!
  if $verbose then puts "opts: #{opts.inspect}" end

  if opts[:category].nil? || opts[:category].nil?
    if opts[:column].nil?
      puts "[Error] (-c CATEGORY and -f FIELD) or (-l COLUMN) are mandatory parameters.\n\n"
      puts optparse
      exit
    end
  end

  # if ARGV is empty at this point no directory or file(s) is specified
  # and the current working directory is used
  if ARGV.empty? then ARGV.push "." end

  files = []
  if File.directory?(ARGV.last) then
    opts[:target_dir] = ARGV.last.chomp("/") # cuts of "/" from the end if present
    files = Dir.glob "#{opts[:target_dir]}/*.csv"
  else
    opts[:target_dir] = File.dirname ARGV.first
    ARGV.each do |filename|
      files.push filename
    end
  end
  puts "Plotting data from #{files.count} file(s)."
  opts[:files] = files
  if $verbose then puts "files: #{files.count} #{files.inspect}" end


  # check if a filename given
  opts[:filename] = nil
  if opts[:output] != nil and !File.directory?(opts[:output])
    opts[:filename] = opts[:output]
  end

  opts
end

if __FILE__ == $0
  opts = read_options_and_arguments

  if opts[:column]
    dataset_container = read_column_from_csv(opts[:files], opts[:column], opts[:no_plot_key], opts[:y_max], opts[:inversion])
  else
    dataset_container = read_csv(opts[:category], opts[:field], opts[:files], opts[:no_plot_key], opts[:y_range], opts[:inversion])
  end
  
  # generate filename
  filename = opts[:filename]
  if filename.nil? || File.directory?(filename) # if an output file is not explicitly stated
    
    if opts[:column] # generate filename
      generated_filename = "dstat-column#{opts[:column]}.png"
    else
      generated_filename = "#{opts[:category]}-#{opts[:field]}.png".sub("/", "_")
    end
    
    if filename.nil? # add directory portion
      filename = File.join(opts[:target_dir], generated_filename)
    elsif File.directory?(filename)
      filename = File.join(filename, generated_filename)
    end
  end
  
  plot(dataset_container, opts[:category], opts[:field], opts[:dry], filename)
end
